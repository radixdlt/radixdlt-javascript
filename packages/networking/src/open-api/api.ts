/* tslint:disable */
/* eslint-disable */
/**
 * Radix Gateway API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.9.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountBalances
 */
export interface AccountBalances {
    /**
     * 
     * @type {TokenAmount}
     * @memberof AccountBalances
     */
    'staked_and_unstaking_balance': TokenAmount;
    /**
     * 
     * @type {Array<TokenAmount>}
     * @memberof AccountBalances
     */
    'liquid_balances': Array<TokenAmount>;
}
/**
 * 
 * @export
 * @interface AccountBalancesRequest
 */
export interface AccountBalancesRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountBalancesRequest
     */
    'network': string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountBalancesRequest
     */
    'account_identifier': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface AccountBalancesResponse
 */
export interface AccountBalancesResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof AccountBalancesResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {AccountBalances}
     * @memberof AccountBalancesResponse
     */
    'account_balances': AccountBalances;
}
/**
 * 
 * @export
 * @interface AccountIdentifier
 */
export interface AccountIdentifier {
    /**
     * 
     * @type {string}
     * @memberof AccountIdentifier
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface AccountStakeEntry
 */
export interface AccountStakeEntry {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof AccountStakeEntry
     */
    'validator_identifier': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof AccountStakeEntry
     */
    'delegated_stake': TokenAmount;
}
/**
 * 
 * @export
 * @interface AccountStakesRequest
 */
export interface AccountStakesRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountStakesRequest
     */
    'network': string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountStakesRequest
     */
    'account_identifier': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface AccountStakesResponse
 */
export interface AccountStakesResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof AccountStakesResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Array<AccountStakeEntry>}
     * @memberof AccountStakesResponse
     */
    'stakes': Array<AccountStakeEntry>;
}
/**
 * 
 * @export
 * @interface AccountTransaction
 */
export interface AccountTransaction {
    /**
     * 
     * @type {AccountTransactionStatus}
     * @memberof AccountTransaction
     */
    'transaction_status': AccountTransactionStatus;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof AccountTransaction
     */
    'transaction_identifier': TransactionIdentifier;
    /**
     * 
     * @type {Array<Action>}
     * @memberof AccountTransaction
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {TokenAmount}
     * @memberof AccountTransaction
     */
    'fee_paid': TokenAmount;
    /**
     * 
     * @type {AccountTransactionMetadata}
     * @memberof AccountTransaction
     */
    'metadata': AccountTransactionMetadata;
}
/**
 * 
 * @export
 * @interface AccountTransactionMetadata
 */
export interface AccountTransactionMetadata {
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionMetadata
     */
    'hex': string;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionMetadata
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AccountTransactionStatus
 */
export interface AccountTransactionStatus {
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionStatus
     */
    'status': AccountTransactionStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionStatus
     */
    'confirmed_time'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AccountTransactionStatusStatusEnum {
    Pending = 'PENDING',
    Confirmed = 'CONFIRMED',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @interface AccountTransactionsRequest
 */
export interface AccountTransactionsRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionsRequest
     */
    'network': string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountTransactionsRequest
     */
    'account_identifier': AccountIdentifier;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionsRequest
     */
    'cursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountTransactionsRequest
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface AccountTransactionsResponse
 */
export interface AccountTransactionsResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof AccountTransactionsResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionsResponse
     */
    'next_cursor'?: string;
    /**
     * 
     * @type {Array<AccountTransaction>}
     * @memberof AccountTransactionsResponse
     */
    'transactions': Array<AccountTransaction>;
}
/**
 * 
 * @export
 * @interface AccountUnstakeEntry
 */
export interface AccountUnstakeEntry {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof AccountUnstakeEntry
     */
    'validator_identifier': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof AccountUnstakeEntry
     */
    'unstaking_amount': TokenAmount;
    /**
     * 
     * @type {number}
     * @memberof AccountUnstakeEntry
     */
    'epochs_until_unlocked': number;
}
/**
 * 
 * @export
 * @interface AccountUnstakesRequest
 */
export interface AccountUnstakesRequest {
    /**
     * 
     * @type {string}
     * @memberof AccountUnstakesRequest
     */
    'network': string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountUnstakesRequest
     */
    'account_identifier': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface AccountUnstakesResponse
 */
export interface AccountUnstakesResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof AccountUnstakesResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Array<AccountUnstakeEntry>}
     * @memberof AccountUnstakesResponse
     */
    'unstakes': Array<AccountUnstakeEntry>;
}
/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface BelowMinimumStakeError
 */
export interface BelowMinimumStakeError extends TransactionBuildError {
    /**
     * 
     * @type {string}
     * @memberof BelowMinimumStakeError
     */
    'requested_amount': string;
    /**
     * 
     * @type {string}
     * @memberof BelowMinimumStakeError
     */
    'minimum_amount': string;
}
/**
 * 
 * @export
 * @interface BelowMinimumStakeErrorAllOf
 */
export interface BelowMinimumStakeErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof BelowMinimumStakeErrorAllOf
     */
    'requested_amount': string;
    /**
     * 
     * @type {string}
     * @memberof BelowMinimumStakeErrorAllOf
     */
    'minimum_amount': string;
}
/**
 * 
 * @export
 * @interface BurnTokens
 */
export interface BurnTokens extends Action {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof BurnTokens
     */
    'from': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof BurnTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface BurnTokensAllOf
 */
export interface BurnTokensAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof BurnTokensAllOf
     */
    'from': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof BurnTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface CouldNotConstructFeesError
 */
export interface CouldNotConstructFeesError extends TransactionBuildError {
    /**
     * 
     * @type {number}
     * @memberof CouldNotConstructFeesError
     */
    'attempts': number;
}
/**
 * 
 * @export
 * @interface CouldNotConstructFeesErrorAllOf
 */
export interface CouldNotConstructFeesErrorAllOf {
    /**
     * 
     * @type {number}
     * @memberof CouldNotConstructFeesErrorAllOf
     */
    'attempts': number;
}
/**
 * 
 * @export
 * @interface CreateTokenDefinition
 */
export interface CreateTokenDefinition extends Action {
    /**
     * 
     * @type {TokenProperties}
     * @memberof CreateTokenDefinition
     */
    'token_properties': TokenProperties;
    /**
     * 
     * @type {TokenAmount}
     * @memberof CreateTokenDefinition
     */
    'token_supply': TokenAmount;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof CreateTokenDefinition
     */
    'to'?: AccountIdentifier;
}
/**
 * 
 * @export
 * @interface CreateTokenDefinitionAllOf
 */
export interface CreateTokenDefinitionAllOf {
    /**
     * 
     * @type {TokenProperties}
     * @memberof CreateTokenDefinitionAllOf
     */
    'token_properties': TokenProperties;
    /**
     * 
     * @type {TokenAmount}
     * @memberof CreateTokenDefinitionAllOf
     */
    'token_supply': TokenAmount;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof CreateTokenDefinitionAllOf
     */
    'to'?: AccountIdentifier;
}
/**
 * 
 * @export
 * @interface EpochRange
 */
export interface EpochRange {
    /**
     * 
     * @type {number}
     * @memberof EpochRange
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof EpochRange
     */
    'to': number;
}
/**
 * 
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError {
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'exception'?: string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'cause'?: string;
}
/**
 * 
 * @export
 * @interface InvalidJsonError
 */
export interface InvalidJsonError {
    /**
     * 
     * @type {string}
     * @memberof InvalidJsonError
     */
    'cause'?: string;
}
/**
 * 
 * @export
 * @interface InvalidRequestError
 */
export interface InvalidRequestError {
    /**
     * 
     * @type {string}
     * @memberof InvalidRequestError
     */
    'pointer'?: string;
    /**
     * 
     * @type {string}
     * @memberof InvalidRequestError
     */
    'cause'?: string;
}
/**
 * 
 * @export
 * @interface LedgerState
 */
export interface LedgerState {
    /**
     * 
     * @type {number}
     * @memberof LedgerState
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof LedgerState
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof LedgerState
     */
    'epoch': number;
    /**
     * 
     * @type {number}
     * @memberof LedgerState
     */
    'round': number;
}
/**
 * 
 * @export
 * @interface MessageTooLongError
 */
export interface MessageTooLongError extends TransactionBuildError {
    /**
     * 
     * @type {number}
     * @memberof MessageTooLongError
     */
    'length_limit': number;
    /**
     * 
     * @type {number}
     * @memberof MessageTooLongError
     */
    'attempted_length': number;
}
/**
 * 
 * @export
 * @interface MessageTooLongErrorAllOf
 */
export interface MessageTooLongErrorAllOf {
    /**
     * 
     * @type {number}
     * @memberof MessageTooLongErrorAllOf
     */
    'length_limit': number;
    /**
     * 
     * @type {number}
     * @memberof MessageTooLongErrorAllOf
     */
    'attempted_length': number;
}
/**
 * 
 * @export
 * @interface MintTokens
 */
export interface MintTokens extends Action {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof MintTokens
     */
    'to': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof MintTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface MintTokensAllOf
 */
export interface MintTokensAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof MintTokensAllOf
     */
    'to': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof MintTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface NetworkResponse
 */
export interface NetworkResponse {
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    'network': string;
    /**
     * 
     * @type {LedgerState}
     * @memberof NetworkResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {TargetLedgerState}
     * @memberof NetworkResponse
     */
    'target_ledger_state'?: TargetLedgerState;
}
/**
 * 
 * @export
 * @interface NotEnoughResourcesError
 */
export interface NotEnoughResourcesError extends TransactionBuildError {
    /**
     * 
     * @type {string}
     * @memberof NotEnoughResourcesError
     */
    'requested_amount': string;
    /**
     * 
     * @type {string}
     * @memberof NotEnoughResourcesError
     */
    'available_amount': string;
}
/**
 * 
 * @export
 * @interface NotEnoughResourcesErrorAllOf
 */
export interface NotEnoughResourcesErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof NotEnoughResourcesErrorAllOf
     */
    'requested_amount': string;
    /**
     * 
     * @type {string}
     * @memberof NotEnoughResourcesErrorAllOf
     */
    'available_amount': string;
}
/**
 * 
 * @export
 * @interface NotValidatorOwnerError
 */
export interface NotValidatorOwnerError extends TransactionBuildError {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof NotValidatorOwnerError
     */
    'owner': AccountIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof NotValidatorOwnerError
     */
    'user': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface NotValidatorOwnerErrorAllOf
 */
export interface NotValidatorOwnerErrorAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof NotValidatorOwnerErrorAllOf
     */
    'owner': AccountIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof NotValidatorOwnerErrorAllOf
     */
    'user': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface StakeTokens
 */
export interface StakeTokens extends Action {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof StakeTokens
     */
    'from': AccountIdentifier;
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof StakeTokens
     */
    'to': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof StakeTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface StakeTokensAllOf
 */
export interface StakeTokensAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof StakeTokensAllOf
     */
    'from': AccountIdentifier;
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof StakeTokensAllOf
     */
    'to': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof StakeTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface TargetLedgerState
 */
export interface TargetLedgerState {
    /**
     * 
     * @type {number}
     * @memberof TargetLedgerState
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof Token
     */
    'token_identifier': TokenIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof Token
     */
    'token_supply': TokenAmount;
    /**
     * 
     * @type {TokenInfo}
     * @memberof Token
     */
    'info': TokenInfo;
    /**
     * 
     * @type {TokenProperties}
     * @memberof Token
     */
    'token_properties': TokenProperties;
}
/**
 * 
 * @export
 * @interface TokenAmount
 */
export interface TokenAmount {
    /**
     * 
     * @type {string}
     * @memberof TokenAmount
     */
    'value': string;
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof TokenAmount
     */
    'token_identifier': TokenIdentifier;
}
/**
 * 
 * @export
 * @interface TokenDeriveRequest
 */
export interface TokenDeriveRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenDeriveRequest
     */
    'network': string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TokenDeriveRequest
     */
    'creator_account_identifier': AccountIdentifier;
    /**
     * 
     * @type {string}
     * @memberof TokenDeriveRequest
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface TokenDeriveResponse
 */
export interface TokenDeriveResponse {
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof TokenDeriveResponse
     */
    'token_identifier': TokenIdentifier;
}
/**
 * 
 * @export
 * @interface TokenIdentifier
 */
export interface TokenIdentifier {
    /**
     * 
     * @type {string}
     * @memberof TokenIdentifier
     */
    'rri': string;
}
/**
 * 
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
    /**
     * 
     * @type {TokenAmount}
     * @memberof TokenInfo
     */
    'total_minted': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof TokenInfo
     */
    'total_burned': TokenAmount;
}
/**
 * 
 * @export
 * @interface TokenNativeRequest
 */
export interface TokenNativeRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenNativeRequest
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface TokenNativeResponse
 */
export interface TokenNativeResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof TokenNativeResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Token}
     * @memberof TokenNativeResponse
     */
    'token': Token;
}
/**
 * 
 * @export
 * @interface TokenProperties
 */
export interface TokenProperties {
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'icon_url': string;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'symbol': string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenProperties
     */
    'is_supply_mutable': boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'granularity': string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TokenProperties
     */
    'owner'?: AccountIdentifier;
}
/**
 * 
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'network': string;
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof TokenRequest
     */
    'token_identifier': TokenIdentifier;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof TokenResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Array<Token>}
     * @memberof TokenResponse
     */
    'token': Array<Token>;
}
/**
 * 
 * @export
 * @interface TransactionBuild
 */
export interface TransactionBuild {
    /**
     * 
     * @type {TokenAmount}
     * @memberof TransactionBuild
     */
    'fee': TokenAmount;
    /**
     * 
     * @type {string}
     * @memberof TransactionBuild
     */
    'unsigned_transaction': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionBuild
     */
    'payload_to_sign': string;
}
/**
 * 
 * @export
 * @interface TransactionBuildError
 */
export interface TransactionBuildError {
    /**
     * 
     * @type {string}
     * @memberof TransactionBuildError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TransactionBuildRequest
 */
export interface TransactionBuildRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionBuildRequest
     */
    'network': string;
    /**
     * 
     * @type {Array<Action>}
     * @memberof TransactionBuildRequest
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransactionBuildRequest
     */
    'fee_payer': AccountIdentifier;
    /**
     * 
     * @type {string}
     * @memberof TransactionBuildRequest
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionBuildRequest
     */
    'disable_token_mint_and_burn'?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionBuildResponse
 */
export interface TransactionBuildResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionBuildResponse
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface TransactionBuildResponseError
 */
export interface TransactionBuildResponseError extends TransactionBuildResponse {
    /**
     * 
     * @type {TransactionBuildError}
     * @memberof TransactionBuildResponseError
     */
    'error': TransactionBuildError;
}
/**
 * 
 * @export
 * @interface TransactionBuildResponseErrorAllOf
 */
export interface TransactionBuildResponseErrorAllOf {
    /**
     * 
     * @type {TransactionBuildError}
     * @memberof TransactionBuildResponseErrorAllOf
     */
    'error': TransactionBuildError;
}
/**
 * 
 * @export
 * @interface TransactionBuildResponseSuccess
 */
export interface TransactionBuildResponseSuccess extends TransactionBuildResponse {
    /**
     * 
     * @type {TransactionBuild}
     * @memberof TransactionBuildResponseSuccess
     */
    'transaction_build': TransactionBuild;
}
/**
 * 
 * @export
 * @interface TransactionBuildResponseSuccessAllOf
 */
export interface TransactionBuildResponseSuccessAllOf {
    /**
     * 
     * @type {TransactionBuild}
     * @memberof TransactionBuildResponseSuccessAllOf
     */
    'transaction_build': TransactionBuild;
}
/**
 * 
 * @export
 * @interface TransactionFinalizeRequest
 */
export interface TransactionFinalizeRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionFinalizeRequest
     */
    'network': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFinalizeRequest
     */
    'unsigned_transaction': string;
    /**
     * 
     * @type {TransactionFinalizeRequestSignature}
     * @memberof TransactionFinalizeRequest
     */
    'signature': TransactionFinalizeRequestSignature;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionFinalizeRequest
     */
    'submit'?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionFinalizeRequestSignature
 */
export interface TransactionFinalizeRequestSignature {
    /**
     * 
     * @type {string}
     * @memberof TransactionFinalizeRequestSignature
     */
    'public_key': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFinalizeRequestSignature
     */
    'bytes': string;
}
/**
 * 
 * @export
 * @interface TransactionFinalizeResponse
 */
export interface TransactionFinalizeResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionFinalizeResponse
     */
    'signed_transaction': string;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionFinalizeResponse
     */
    'transaction_identifier': TransactionIdentifier;
}
/**
 * 
 * @export
 * @interface TransactionIdentifier
 */
export interface TransactionIdentifier {
    /**
     * 
     * @type {string}
     * @memberof TransactionIdentifier
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface TransactionRules
 */
export interface TransactionRules {
    /**
     * 
     * @type {number}
     * @memberof TransactionRules
     */
    'maximum_message_length'?: number;
    /**
     * 
     * @type {TokenAmount}
     * @memberof TransactionRules
     */
    'minimum_stake'?: TokenAmount;
}
/**
 * 
 * @export
 * @interface TransactionRulesRequest
 */
export interface TransactionRulesRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionRulesRequest
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface TransactionRulesResponse
 */
export interface TransactionRulesResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof TransactionRulesResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {TransactionRules}
     * @memberof TransactionRulesResponse
     */
    'transaction_rules': TransactionRules;
}
/**
 * 
 * @export
 * @interface TransactionStatusRequest
 */
export interface TransactionStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionStatusRequest
     */
    'network': string;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionStatusRequest
     */
    'transaction_identifier': TransactionIdentifier;
}
/**
 * 
 * @export
 * @interface TransactionStatusResponse
 */
export interface TransactionStatusResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof TransactionStatusResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Array<AccountTransaction>}
     * @memberof TransactionStatusResponse
     */
    'transaction': Array<AccountTransaction>;
}
/**
 * 
 * @export
 * @interface TransactionSubmitRequest
 */
export interface TransactionSubmitRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionSubmitRequest
     */
    'network': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionSubmitRequest
     */
    'signed_transaction': string;
}
/**
 * 
 * @export
 * @interface TransactionSubmitResponse
 */
export interface TransactionSubmitResponse {
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionSubmitResponse
     */
    'transaction_identifier': TransactionIdentifier;
}
/**
 * 
 * @export
 * @interface TransferTokens
 */
export interface TransferTokens extends Action {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransferTokens
     */
    'from': AccountIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransferTokens
     */
    'to': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof TransferTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface TransferTokensAllOf
 */
export interface TransferTokensAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransferTokensAllOf
     */
    'from': AccountIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransferTokensAllOf
     */
    'to': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof TransferTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface UnexpectedError
 */
export interface UnexpectedError {
    /**
     * 
     * @type {string}
     * @memberof UnexpectedError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface UnstakeTokens
 */
export interface UnstakeTokens extends Action {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof UnstakeTokens
     */
    'from': ValidatorIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof UnstakeTokens
     */
    'to': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof UnstakeTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface UnstakeTokensAllOf
 */
export interface UnstakeTokensAllOf {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof UnstakeTokensAllOf
     */
    'from': ValidatorIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof UnstakeTokensAllOf
     */
    'to': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof UnstakeTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof Validator
     */
    'validator_identifier': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof Validator
     */
    'stake': TokenAmount;
    /**
     * 
     * @type {ValidatorInfo}
     * @memberof Validator
     */
    'info': ValidatorInfo;
    /**
     * 
     * @type {ValidatorProperties}
     * @memberof Validator
     */
    'properties': ValidatorProperties;
}
/**
 * 
 * @export
 * @interface ValidatorIdentifier
 */
export interface ValidatorIdentifier {
    /**
     * 
     * @type {string}
     * @memberof ValidatorIdentifier
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface ValidatorInfo
 */
export interface ValidatorInfo {
    /**
     * 
     * @type {TokenAmount}
     * @memberof ValidatorInfo
     */
    'owner_stake': TokenAmount;
    /**
     * 
     * @type {ValidatorUptime}
     * @memberof ValidatorInfo
     */
    'uptime': ValidatorUptime;
}
/**
 * 
 * @export
 * @interface ValidatorInfoRequest
 */
export interface ValidatorInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatorInfoRequest
     */
    'network': string;
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof ValidatorInfoRequest
     */
    'validator_identifier': ValidatorIdentifier;
}
/**
 * 
 * @export
 * @interface ValidatorInfoResponse
 */
export interface ValidatorInfoResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof ValidatorInfoResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Validator}
     * @memberof ValidatorInfoResponse
     */
    'validator': Validator;
}
/**
 * 
 * @export
 * @interface ValidatorProperties
 */
export interface ValidatorProperties {
    /**
     * 
     * @type {string}
     * @memberof ValidatorProperties
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ValidatorProperties
     */
    'validator_fee': string;
    /**
     * 
     * @type {string}
     * @memberof ValidatorProperties
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ValidatorProperties
     */
    'registered': boolean;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof ValidatorProperties
     */
    'owner_account_identifier': AccountIdentifier;
    /**
     * 
     * @type {boolean}
     * @memberof ValidatorProperties
     */
    'external_stake_accepted': boolean;
}
/**
 * 
 * @export
 * @interface ValidatorUptime
 */
export interface ValidatorUptime {
    /**
     * 
     * @type {EpochRange}
     * @memberof ValidatorUptime
     */
    'epoch_range': EpochRange;
    /**
     * 
     * @type {string}
     * @memberof ValidatorUptime
     */
    'uptime_percentage': string;
    /**
     * 
     * @type {number}
     * @memberof ValidatorUptime
     */
    'proposals_missed': number;
    /**
     * 
     * @type {number}
     * @memberof ValidatorUptime
     */
    'proposals_completed': number;
}
/**
 * 
 * @export
 * @interface ValidatorsRequest
 */
export interface ValidatorsRequest {
    /**
     * 
     * @type {string}
     * @memberof ValidatorsRequest
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface ValidatorsResponse
 */
export interface ValidatorsResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof ValidatorsResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Array<Validator>}
     * @memberof ValidatorsResponse
     */
    'validators': Array<Validator>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalancesPost: async (accountBalancesRequest: AccountBalancesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountBalancesRequest' is not null or undefined
            assertParamExists('accountBalancesPost', 'accountBalancesRequest', accountBalancesRequest)
            const localVarPath = `/account/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountBalancesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStakesPost: async (accountStakesRequest: AccountStakesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountStakesRequest' is not null or undefined
            assertParamExists('accountStakesPost', 'accountStakesRequest', accountStakesRequest)
            const localVarPath = `/account/stakes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountStakesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsPost: async (accountTransactionsRequest: AccountTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountTransactionsRequest' is not null or undefined
            assertParamExists('accountTransactionsPost', 'accountTransactionsRequest', accountTransactionsRequest)
            const localVarPath = `/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUnstakesPost: async (accountUnstakesRequest: AccountUnstakesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountUnstakesRequest' is not null or undefined
            assertParamExists('accountUnstakesPost', 'accountUnstakesRequest', accountUnstakesRequest)
            const localVarPath = `/account/unstakes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUnstakesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Network
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('networkPost', 'body', body)
            const localVarPath = `/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDerivePost: async (tokenDeriveRequest: TokenDeriveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenDeriveRequest' is not null or undefined
            assertParamExists('tokenDerivePost', 'tokenDeriveRequest', tokenDeriveRequest)
            const localVarPath = `/token/derive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenDeriveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenNativePost: async (tokenNativeRequest: TokenNativeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenNativeRequest' is not null or undefined
            assertParamExists('tokenNativePost', 'tokenNativeRequest', tokenNativeRequest)
            const localVarPath = `/token/native`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenNativeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: async (tokenRequest: TokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequest' is not null or undefined
            assertParamExists('tokenPost', 'tokenRequest', tokenRequest)
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionBuildPost: async (transactionBuildRequest: TransactionBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionBuildRequest' is not null or undefined
            assertParamExists('transactionBuildPost', 'transactionBuildRequest', transactionBuildRequest)
            const localVarPath = `/transaction/build`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionFinalizePost: async (transactionFinalizeRequest: TransactionFinalizeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionFinalizeRequest' is not null or undefined
            assertParamExists('transactionFinalizePost', 'transactionFinalizeRequest', transactionFinalizeRequest)
            const localVarPath = `/transaction/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionFinalizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRulesPost: async (transactionRulesRequest: TransactionRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRulesRequest' is not null or undefined
            assertParamExists('transactionRulesPost', 'transactionRulesRequest', transactionRulesRequest)
            const localVarPath = `/transaction/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transaction
         * @param {TransactionStatusRequest} transactionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionStatusPost: async (transactionStatusRequest: TransactionStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionStatusRequest' is not null or undefined
            assertParamExists('transactionStatusPost', 'transactionStatusRequest', transactionStatusRequest)
            const localVarPath = `/transaction/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionSubmitPost: async (transactionSubmitRequest: TransactionSubmitRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionSubmitRequest' is not null or undefined
            assertParamExists('transactionSubmitPost', 'transactionSubmitRequest', transactionSubmitRequest)
            const localVarPath = `/transaction/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionSubmitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Validator
         * @param {ValidatorInfoRequest} validatorInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorPost: async (validatorInfoRequest: ValidatorInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorInfoRequest' is not null or undefined
            assertParamExists('validatorPost', 'validatorInfoRequest', validatorInfoRequest)
            const localVarPath = `/validator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsPost: async (validatorsRequest: ValidatorsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorsRequest' is not null or undefined
            assertParamExists('validatorsPost', 'validatorsRequest', validatorsRequest)
            const localVarPath = `/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountBalancesPost(accountBalancesRequest: AccountBalancesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountBalancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountBalancesPost(accountBalancesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountStakesPost(accountStakesRequest: AccountStakesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountStakesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountStakesPost(accountStakesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountTransactionsPost(accountTransactionsRequest: AccountTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountTransactionsPost(accountTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountUnstakesPost(accountUnstakesRequest: AccountUnstakesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountUnstakesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountUnstakesPost(accountUnstakesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Network
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDerivePost(tokenDeriveRequest: TokenDeriveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDeriveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDerivePost(tokenDeriveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenNativePost(tokenNativeRequest: TokenNativeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenNativeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenNativePost(tokenNativeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPost(tokenRequest: TokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(tokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionBuildPost(transactionBuildRequest: TransactionBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionBuildResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionBuildPost(transactionBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionFinalizePost(transactionFinalizeRequest: TransactionFinalizeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionFinalizeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionFinalizePost(transactionFinalizeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionRulesPost(transactionRulesRequest: TransactionRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionRulesPost(transactionRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Transaction
         * @param {TransactionStatusRequest} transactionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionStatusPost(transactionStatusRequest: TransactionStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionStatusPost(transactionStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionSubmitPost(transactionSubmitRequest: TransactionSubmitRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSubmitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionSubmitPost(transactionSubmitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Validator
         * @param {ValidatorInfoRequest} validatorInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorPost(validatorInfoRequest: ValidatorInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorPost(validatorInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsPost(validatorsRequest: ValidatorsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsPost(validatorsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalancesPost(accountBalancesRequest: AccountBalancesRequest, options?: any): AxiosPromise<AccountBalancesResponse> {
            return localVarFp.accountBalancesPost(accountBalancesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStakesPost(accountStakesRequest: AccountStakesRequest, options?: any): AxiosPromise<AccountStakesResponse> {
            return localVarFp.accountStakesPost(accountStakesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsPost(accountTransactionsRequest: AccountTransactionsRequest, options?: any): AxiosPromise<AccountTransactionsResponse> {
            return localVarFp.accountTransactionsPost(accountTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUnstakesPost(accountUnstakesRequest: AccountUnstakesRequest, options?: any): AxiosPromise<AccountUnstakesResponse> {
            return localVarFp.accountUnstakesPost(accountUnstakesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Network
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkPost(body: object, options?: any): AxiosPromise<NetworkResponse> {
            return localVarFp.networkPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDerivePost(tokenDeriveRequest: TokenDeriveRequest, options?: any): AxiosPromise<TokenDeriveResponse> {
            return localVarFp.tokenDerivePost(tokenDeriveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenNativePost(tokenNativeRequest: TokenNativeRequest, options?: any): AxiosPromise<TokenNativeResponse> {
            return localVarFp.tokenNativePost(tokenNativeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(tokenRequest: TokenRequest, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.tokenPost(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionBuildPost(transactionBuildRequest: TransactionBuildRequest, options?: any): AxiosPromise<TransactionBuildResponse> {
            return localVarFp.transactionBuildPost(transactionBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionFinalizePost(transactionFinalizeRequest: TransactionFinalizeRequest, options?: any): AxiosPromise<TransactionFinalizeResponse> {
            return localVarFp.transactionFinalizePost(transactionFinalizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRulesPost(transactionRulesRequest: TransactionRulesRequest, options?: any): AxiosPromise<TransactionRulesResponse> {
            return localVarFp.transactionRulesPost(transactionRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transaction
         * @param {TransactionStatusRequest} transactionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionStatusPost(transactionStatusRequest: TransactionStatusRequest, options?: any): AxiosPromise<TransactionStatusResponse> {
            return localVarFp.transactionStatusPost(transactionStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionSubmitPost(transactionSubmitRequest: TransactionSubmitRequest, options?: any): AxiosPromise<TransactionSubmitResponse> {
            return localVarFp.transactionSubmitPost(transactionSubmitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Validator
         * @param {ValidatorInfoRequest} validatorInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorPost(validatorInfoRequest: ValidatorInfoRequest, options?: any): AxiosPromise<ValidatorInfoResponse> {
            return localVarFp.validatorPost(validatorInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsPost(validatorsRequest: ValidatorsRequest, options?: any): AxiosPromise<ValidatorsResponse> {
            return localVarFp.validatorsPost(validatorsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get Account Balances
     * @param {AccountBalancesRequest} accountBalancesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountBalancesPost(accountBalancesRequest: AccountBalancesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountBalancesPost(accountBalancesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Stake Positions
     * @param {AccountStakesRequest} accountStakesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountStakesPost(accountStakesRequest: AccountStakesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountStakesPost(accountStakesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Account Transactions
     * @param {AccountTransactionsRequest} accountTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountTransactionsPost(accountTransactionsRequest: AccountTransactionsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountTransactionsPost(accountTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Unstake Positions
     * @param {AccountUnstakesRequest} accountUnstakesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountUnstakesPost(accountUnstakesRequest: AccountUnstakesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountUnstakesPost(accountUnstakesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Network
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public networkPost(body: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).networkPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Derive Token Identifier
     * @param {TokenDeriveRequest} tokenDeriveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenDerivePost(tokenDeriveRequest: TokenDeriveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenDerivePost(tokenDeriveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Native Token Info
     * @param {TokenNativeRequest} tokenNativeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenNativePost(tokenNativeRequest: TokenNativeRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenNativePost(tokenNativeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token Info
     * @param {TokenRequest} tokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenPost(tokenRequest: TokenRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenPost(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Build Transaction
     * @param {TransactionBuildRequest} transactionBuildRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionBuildPost(transactionBuildRequest: TransactionBuildRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionBuildPost(transactionBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finalize Transaction
     * @param {TransactionFinalizeRequest} transactionFinalizeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionFinalizePost(transactionFinalizeRequest: TransactionFinalizeRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionFinalizePost(transactionFinalizeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transaction Rules
     * @param {TransactionRulesRequest} transactionRulesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionRulesPost(transactionRulesRequest: TransactionRulesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionRulesPost(transactionRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transaction
     * @param {TransactionStatusRequest} transactionStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionStatusPost(transactionStatusRequest: TransactionStatusRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionStatusPost(transactionStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit Transaction
     * @param {TransactionSubmitRequest} transactionSubmitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionSubmitPost(transactionSubmitRequest: TransactionSubmitRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionSubmitPost(transactionSubmitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Validator
     * @param {ValidatorInfoRequest} validatorInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public validatorPost(validatorInfoRequest: ValidatorInfoRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).validatorPost(validatorInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Validators
     * @param {ValidatorsRequest} validatorsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public validatorsPost(validatorsRequest: ValidatorsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).validatorsPost(validatorsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


