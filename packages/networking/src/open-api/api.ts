/* tslint:disable */
/* eslint-disable */
/**
 * Radix Gateway API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.9.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountBalances
 */
export interface AccountBalances {
    /**
     * 
     * @type {TokenAmount}
     * @memberof AccountBalances
     */
    'staked_and_unstaking_balance': TokenAmount;
    /**
     * 
     * @type {Array<TokenAmount>}
     * @memberof AccountBalances
     */
    'liquid_balances': Array<TokenAmount>;
}
/**
 * 
 * @export
 * @interface AccountBalancesRequest
 */
export interface AccountBalancesRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof AccountBalancesRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountBalancesRequest
     */
    'account_identifier': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface AccountBalancesResponse
 */
export interface AccountBalancesResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof AccountBalancesResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {AccountBalances}
     * @memberof AccountBalancesResponse
     */
    'account_balances': AccountBalances;
}
/**
 * 
 * @export
 * @interface AccountDeriveRequest
 */
export interface AccountDeriveRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof AccountDeriveRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {PublicKey}
     * @memberof AccountDeriveRequest
     */
    'public_key': PublicKey;
}
/**
 * 
 * @export
 * @interface AccountDeriveResponse
 */
export interface AccountDeriveResponse {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountDeriveResponse
     */
    'account_identifier': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface AccountIdentifier
 */
export interface AccountIdentifier {
    /**
     * 
     * @type {string}
     * @memberof AccountIdentifier
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface AccountStakeEntry
 */
export interface AccountStakeEntry {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof AccountStakeEntry
     */
    'validator_identifier': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof AccountStakeEntry
     */
    'delegated_stake': TokenAmount;
}
/**
 * 
 * @export
 * @interface AccountStakesRequest
 */
export interface AccountStakesRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof AccountStakesRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountStakesRequest
     */
    'account_identifier': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface AccountStakesResponse
 */
export interface AccountStakesResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof AccountStakesResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Array<AccountStakeEntry>}
     * @memberof AccountStakesResponse
     */
    'pending_stakes': Array<AccountStakeEntry>;
    /**
     * 
     * @type {Array<AccountStakeEntry>}
     * @memberof AccountStakesResponse
     */
    'stakes': Array<AccountStakeEntry>;
}
/**
 * 
 * @export
 * @interface AccountTransaction
 */
export interface AccountTransaction {
    /**
     * 
     * @type {AccountTransactionStatus}
     * @memberof AccountTransaction
     */
    'transaction_status': AccountTransactionStatus;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof AccountTransaction
     */
    'transaction_identifier': TransactionIdentifier;
    /**
     * 
     * @type {Array<Action>}
     * @memberof AccountTransaction
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {TokenAmount}
     * @memberof AccountTransaction
     */
    'fee_paid': TokenAmount;
    /**
     * 
     * @type {AccountTransactionMetadata}
     * @memberof AccountTransaction
     */
    'metadata': AccountTransactionMetadata;
}
/**
 * 
 * @export
 * @interface AccountTransactionMetadata
 */
export interface AccountTransactionMetadata {
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionMetadata
     */
    'hex': string;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionMetadata
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface AccountTransactionStatus
 */
export interface AccountTransactionStatus {
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionStatus
     */
    'status': AccountTransactionStatusStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionStatus
     */
    'confirmed_time'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AccountTransactionStatusStatusEnum {
    Pending = 'PENDING',
    Confirmed = 'CONFIRMED',
    Failed = 'FAILED'
}

/**
 * 
 * @export
 * @interface AccountTransactionsRequest
 */
export interface AccountTransactionsRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof AccountTransactionsRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountTransactionsRequest
     */
    'account_identifier': AccountIdentifier;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionsRequest
     */
    'cursor'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccountTransactionsRequest
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface AccountTransactionsResponse
 */
export interface AccountTransactionsResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof AccountTransactionsResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {number}
     * @memberof AccountTransactionsResponse
     */
    'total_count'?: number;
    /**
     * 
     * @type {string}
     * @memberof AccountTransactionsResponse
     */
    'next_cursor'?: string;
    /**
     * 
     * @type {Array<AccountTransaction>}
     * @memberof AccountTransactionsResponse
     */
    'transactions': Array<AccountTransaction>;
}
/**
 * 
 * @export
 * @interface AccountUnstakeEntry
 */
export interface AccountUnstakeEntry {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof AccountUnstakeEntry
     */
    'validator_identifier': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof AccountUnstakeEntry
     */
    'unstaking_amount': TokenAmount;
    /**
     * 
     * @type {number}
     * @memberof AccountUnstakeEntry
     */
    'epochs_until_unlocked': number;
}
/**
 * 
 * @export
 * @interface AccountUnstakesRequest
 */
export interface AccountUnstakesRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof AccountUnstakesRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountUnstakesRequest
     */
    'account_identifier': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface AccountUnstakesResponse
 */
export interface AccountUnstakesResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof AccountUnstakesResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Array<AccountUnstakeEntry>}
     * @memberof AccountUnstakesResponse
     */
    'pending_unstakes': Array<AccountUnstakeEntry>;
    /**
     * 
     * @type {Array<AccountUnstakeEntry>}
     * @memberof AccountUnstakesResponse
     */
    'unstakes': Array<AccountUnstakeEntry>;
}
/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface BelowMinimumStakeError
 */
export interface BelowMinimumStakeError extends GatewayError {
    /**
     * 
     * @type {TokenAmount}
     * @memberof BelowMinimumStakeError
     */
    'requested_amount': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof BelowMinimumStakeError
     */
    'minimum_amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface BelowMinimumStakeErrorAllOf
 */
export interface BelowMinimumStakeErrorAllOf {
    /**
     * 
     * @type {TokenAmount}
     * @memberof BelowMinimumStakeErrorAllOf
     */
    'requested_amount': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof BelowMinimumStakeErrorAllOf
     */
    'minimum_amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface BurnTokens
 */
export interface BurnTokens extends Action {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof BurnTokens
     */
    'from_account': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof BurnTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface BurnTokensAllOf
 */
export interface BurnTokensAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof BurnTokensAllOf
     */
    'from_account': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof BurnTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface CannotStakeError
 */
export interface CannotStakeError extends GatewayError {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof CannotStakeError
     */
    'owner': AccountIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof CannotStakeError
     */
    'user': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface CannotStakeErrorAllOf
 */
export interface CannotStakeErrorAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof CannotStakeErrorAllOf
     */
    'owner': AccountIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof CannotStakeErrorAllOf
     */
    'user': AccountIdentifier;
}
/**
 * 
 * @export
 * @interface CouldNotConstructFeesError
 */
export interface CouldNotConstructFeesError extends GatewayError {
    /**
     * 
     * @type {number}
     * @memberof CouldNotConstructFeesError
     */
    'attempts': number;
}
/**
 * 
 * @export
 * @interface CouldNotConstructFeesErrorAllOf
 */
export interface CouldNotConstructFeesErrorAllOf {
    /**
     * 
     * @type {number}
     * @memberof CouldNotConstructFeesErrorAllOf
     */
    'attempts': number;
}
/**
 * 
 * @export
 * @interface CreateTokenDefinition
 */
export interface CreateTokenDefinition extends Action {
    /**
     * 
     * @type {TokenProperties}
     * @memberof CreateTokenDefinition
     */
    'token_properties': TokenProperties;
    /**
     * 
     * @type {TokenAmount}
     * @memberof CreateTokenDefinition
     */
    'token_supply': TokenAmount;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof CreateTokenDefinition
     */
    'to_account'?: AccountIdentifier;
}
/**
 * 
 * @export
 * @interface CreateTokenDefinitionAllOf
 */
export interface CreateTokenDefinitionAllOf {
    /**
     * 
     * @type {TokenProperties}
     * @memberof CreateTokenDefinitionAllOf
     */
    'token_properties': TokenProperties;
    /**
     * 
     * @type {TokenAmount}
     * @memberof CreateTokenDefinitionAllOf
     */
    'token_supply': TokenAmount;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof CreateTokenDefinitionAllOf
     */
    'to_account'?: AccountIdentifier;
}
/**
 * 
 * @export
 * @interface EpochRange
 */
export interface EpochRange {
    /**
     * 
     * @type {number}
     * @memberof EpochRange
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof EpochRange
     */
    'to': number;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {number}
     * @memberof ErrorResponse
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ErrorResponse
     */
    'message': string;
    /**
     * 
     * @type {GatewayError}
     * @memberof ErrorResponse
     */
    'details'?: GatewayError;
}
/**
 * 
 * @export
 * @interface GatewayError
 */
export interface GatewayError {
    /**
     * 
     * @type {string}
     * @memberof GatewayError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface GatewayResponse
 */
export interface GatewayResponse {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof GatewayResponse
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {LedgerState}
     * @memberof GatewayResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {TargetLedgerState}
     * @memberof GatewayResponse
     */
    'target_ledger_state'?: TargetLedgerState;
}
/**
 * 
 * @export
 * @interface InternalServerError
 */
export interface InternalServerError extends GatewayError {
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'exception': string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerError
     */
    'cause': string;
}
/**
 * 
 * @export
 * @interface InternalServerErrorAllOf
 */
export interface InternalServerErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorAllOf
     */
    'exception': string;
    /**
     * 
     * @type {string}
     * @memberof InternalServerErrorAllOf
     */
    'cause': string;
}
/**
 * 
 * @export
 * @interface InvalidAccountAddressError
 */
export interface InvalidAccountAddressError extends GatewayError {
    /**
     * 
     * @type {string}
     * @memberof InvalidAccountAddressError
     */
    'invalid_account_address': string;
}
/**
 * 
 * @export
 * @interface InvalidAccountAddressErrorAllOf
 */
export interface InvalidAccountAddressErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof InvalidAccountAddressErrorAllOf
     */
    'invalid_account_address': string;
}
/**
 * 
 * @export
 * @interface InvalidActionError
 */
export interface InvalidActionError extends GatewayError {
    /**
     * 
     * @type {Action}
     * @memberof InvalidActionError
     */
    'invalid_action': Action;
}
/**
 * 
 * @export
 * @interface InvalidActionErrorAllOf
 */
export interface InvalidActionErrorAllOf {
    /**
     * 
     * @type {Action}
     * @memberof InvalidActionErrorAllOf
     */
    'invalid_action': Action;
}
/**
 * 
 * @export
 * @interface InvalidPublicKeyError
 */
export interface InvalidPublicKeyError extends GatewayError {
    /**
     * 
     * @type {string}
     * @memberof InvalidPublicKeyError
     */
    'invalid_public_key': string;
}
/**
 * 
 * @export
 * @interface InvalidPublicKeyErrorAllOf
 */
export interface InvalidPublicKeyErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof InvalidPublicKeyErrorAllOf
     */
    'invalid_public_key': string;
}
/**
 * 
 * @export
 * @interface InvalidRequestError
 */
export interface InvalidRequestError extends GatewayError {
    /**
     * 
     * @type {string}
     * @memberof InvalidRequestError
     */
    'exception': string;
    /**
     * 
     * @type {string}
     * @memberof InvalidRequestError
     */
    'cause': string;
}
/**
 * 
 * @export
 * @interface InvalidSignatureError
 */
export interface InvalidSignatureError extends GatewayError {
    /**
     * 
     * @type {Signature}
     * @memberof InvalidSignatureError
     */
    'invalid_signature': Signature;
}
/**
 * 
 * @export
 * @interface InvalidSignatureErrorAllOf
 */
export interface InvalidSignatureErrorAllOf {
    /**
     * 
     * @type {Signature}
     * @memberof InvalidSignatureErrorAllOf
     */
    'invalid_signature': Signature;
}
/**
 * 
 * @export
 * @interface InvalidTokenRRIError
 */
export interface InvalidTokenRRIError extends GatewayError {
    /**
     * 
     * @type {string}
     * @memberof InvalidTokenRRIError
     */
    'invalid_rri': string;
}
/**
 * 
 * @export
 * @interface InvalidTokenRRIErrorAllOf
 */
export interface InvalidTokenRRIErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof InvalidTokenRRIErrorAllOf
     */
    'invalid_rri': string;
}
/**
 * 
 * @export
 * @interface InvalidTokenSymbolError
 */
export interface InvalidTokenSymbolError extends GatewayError {
    /**
     * 
     * @type {string}
     * @memberof InvalidTokenSymbolError
     */
    'invalid_token_symbol': string;
}
/**
 * 
 * @export
 * @interface InvalidTokenSymbolErrorAllOf
 */
export interface InvalidTokenSymbolErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof InvalidTokenSymbolErrorAllOf
     */
    'invalid_token_symbol': string;
}
/**
 * 
 * @export
 * @interface InvalidTransactionError
 */
export interface InvalidTransactionError extends GatewayError {
    /**
     * 
     * @type {string}
     * @memberof InvalidTransactionError
     */
    'invalid_transaction': string;
    /**
     * 
     * @type {string}
     * @memberof InvalidTransactionError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface InvalidTransactionErrorAllOf
 */
export interface InvalidTransactionErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof InvalidTransactionErrorAllOf
     */
    'invalid_transaction': string;
    /**
     * 
     * @type {string}
     * @memberof InvalidTransactionErrorAllOf
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface InvalidValidatorAddressError
 */
export interface InvalidValidatorAddressError extends GatewayError {
    /**
     * 
     * @type {string}
     * @memberof InvalidValidatorAddressError
     */
    'invalid_account_address'?: string;
}
/**
 * 
 * @export
 * @interface InvalidValidatorAddressErrorAllOf
 */
export interface InvalidValidatorAddressErrorAllOf {
    /**
     * 
     * @type {string}
     * @memberof InvalidValidatorAddressErrorAllOf
     */
    'invalid_account_address'?: string;
}
/**
 * 
 * @export
 * @interface LedgerState
 */
export interface LedgerState {
    /**
     * 
     * @type {number}
     * @memberof LedgerState
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof LedgerState
     */
    'timestamp': string;
    /**
     * 
     * @type {number}
     * @memberof LedgerState
     */
    'epoch': number;
    /**
     * 
     * @type {number}
     * @memberof LedgerState
     */
    'round': number;
}
/**
 * 
 * @export
 * @interface MessageTooLongError
 */
export interface MessageTooLongError extends GatewayError {
    /**
     * 
     * @type {number}
     * @memberof MessageTooLongError
     */
    'length_limit': number;
    /**
     * 
     * @type {number}
     * @memberof MessageTooLongError
     */
    'attempted_length': number;
}
/**
 * 
 * @export
 * @interface MessageTooLongErrorAllOf
 */
export interface MessageTooLongErrorAllOf {
    /**
     * 
     * @type {number}
     * @memberof MessageTooLongErrorAllOf
     */
    'length_limit': number;
    /**
     * 
     * @type {number}
     * @memberof MessageTooLongErrorAllOf
     */
    'attempted_length': number;
}
/**
 * 
 * @export
 * @interface MintTokens
 */
export interface MintTokens extends Action {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof MintTokens
     */
    'to_account': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof MintTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface MintTokensAllOf
 */
export interface MintTokensAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof MintTokensAllOf
     */
    'to_account': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof MintTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface NetworkIdentifier
 */
export interface NetworkIdentifier {
    /**
     * 
     * @type {string}
     * @memberof NetworkIdentifier
     */
    'network': string;
}
/**
 * 
 * @export
 * @interface NetworkNotSupportedError
 */
export interface NetworkNotSupportedError extends GatewayError {
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkNotSupportedError
     */
    'networks_supported': Array<string>;
}
/**
 * 
 * @export
 * @interface NetworkNotSupportedErrorAllOf
 */
export interface NetworkNotSupportedErrorAllOf {
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkNotSupportedErrorAllOf
     */
    'networks_supported': Array<string>;
}
/**
 * 
 * @export
 * @interface NotEnoughNativeTokensForFeesError
 */
export interface NotEnoughNativeTokensForFeesError extends GatewayError {
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughNativeTokensForFeesError
     */
    'required_amount': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughNativeTokensForFeesError
     */
    'available_amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface NotEnoughNativeTokensForFeesErrorAllOf
 */
export interface NotEnoughNativeTokensForFeesErrorAllOf {
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughNativeTokensForFeesErrorAllOf
     */
    'required_amount': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughNativeTokensForFeesErrorAllOf
     */
    'available_amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface NotEnoughTokensForStakeError
 */
export interface NotEnoughTokensForStakeError extends GatewayError {
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughTokensForStakeError
     */
    'requested_amount': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughTokensForStakeError
     */
    'available_amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface NotEnoughTokensForTransferError
 */
export interface NotEnoughTokensForTransferError extends GatewayError {
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughTokensForTransferError
     */
    'requested_amount': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughTokensForTransferError
     */
    'available_amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface NotEnoughTokensForTransferErrorAllOf
 */
export interface NotEnoughTokensForTransferErrorAllOf {
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughTokensForTransferErrorAllOf
     */
    'requested_amount': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughTokensForTransferErrorAllOf
     */
    'available_amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface NotEnoughTokensForUnstakeError
 */
export interface NotEnoughTokensForUnstakeError extends GatewayError {
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughTokensForUnstakeError
     */
    'requested_amount': TokenAmount;
    /**
     * 
     * @type {AccountStakeEntry}
     * @memberof NotEnoughTokensForUnstakeError
     */
    'stake': AccountStakeEntry;
    /**
     * 
     * @type {AccountStakeEntry}
     * @memberof NotEnoughTokensForUnstakeError
     */
    'pending_stake': AccountStakeEntry;
}
/**
 * 
 * @export
 * @interface NotEnoughTokensForUnstakeErrorAllOf
 */
export interface NotEnoughTokensForUnstakeErrorAllOf {
    /**
     * 
     * @type {TokenAmount}
     * @memberof NotEnoughTokensForUnstakeErrorAllOf
     */
    'requested_amount': TokenAmount;
    /**
     * 
     * @type {AccountStakeEntry}
     * @memberof NotEnoughTokensForUnstakeErrorAllOf
     */
    'stake': AccountStakeEntry;
    /**
     * 
     * @type {AccountStakeEntry}
     * @memberof NotEnoughTokensForUnstakeErrorAllOf
     */
    'pending_stake': AccountStakeEntry;
}
/**
 * 
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * 
     * @type {string}
     * @memberof PublicKey
     */
    'hex': string;
}
/**
 * 
 * @export
 * @interface Signature
 */
export interface Signature {
    /**
     * 
     * @type {PublicKey}
     * @memberof Signature
     */
    'public_key': PublicKey;
    /**
     * 
     * @type {string}
     * @memberof Signature
     */
    'bytes': string;
}
/**
 * 
 * @export
 * @interface StakeTokens
 */
export interface StakeTokens extends Action {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof StakeTokens
     */
    'from_account': AccountIdentifier;
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof StakeTokens
     */
    'to_validator': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof StakeTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface StakeTokensAllOf
 */
export interface StakeTokensAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof StakeTokensAllOf
     */
    'from_account': AccountIdentifier;
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof StakeTokensAllOf
     */
    'to_validator': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof StakeTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface TargetLedgerState
 */
export interface TargetLedgerState {
    /**
     * 
     * @type {number}
     * @memberof TargetLedgerState
     */
    'version': number;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof Token
     */
    'token_identifier': TokenIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof Token
     */
    'token_supply': TokenAmount;
    /**
     * 
     * @type {TokenInfo}
     * @memberof Token
     */
    'info': TokenInfo;
    /**
     * 
     * @type {TokenProperties}
     * @memberof Token
     */
    'token_properties': TokenProperties;
}
/**
 * 
 * @export
 * @interface TokenAmount
 */
export interface TokenAmount {
    /**
     * 
     * @type {string}
     * @memberof TokenAmount
     */
    'value': string;
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof TokenAmount
     */
    'token_identifier': TokenIdentifier;
}
/**
 * 
 * @export
 * @interface TokenDeriveRequest
 */
export interface TokenDeriveRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof TokenDeriveRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {PublicKey}
     * @memberof TokenDeriveRequest
     */
    'public_key': PublicKey;
    /**
     * 
     * @type {string}
     * @memberof TokenDeriveRequest
     */
    'symbol': string;
}
/**
 * 
 * @export
 * @interface TokenDeriveResponse
 */
export interface TokenDeriveResponse {
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof TokenDeriveResponse
     */
    'token_identifier': TokenIdentifier;
}
/**
 * 
 * @export
 * @interface TokenIdentifier
 */
export interface TokenIdentifier {
    /**
     * 
     * @type {string}
     * @memberof TokenIdentifier
     */
    'rri': string;
}
/**
 * 
 * @export
 * @interface TokenInfo
 */
export interface TokenInfo {
    /**
     * 
     * @type {TokenAmount}
     * @memberof TokenInfo
     */
    'total_minted': TokenAmount;
    /**
     * 
     * @type {TokenAmount}
     * @memberof TokenInfo
     */
    'total_burned': TokenAmount;
}
/**
 * 
 * @export
 * @interface TokenNativeRequest
 */
export interface TokenNativeRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof TokenNativeRequest
     */
    'network_identifier': NetworkIdentifier;
}
/**
 * 
 * @export
 * @interface TokenNativeResponse
 */
export interface TokenNativeResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof TokenNativeResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Token}
     * @memberof TokenNativeResponse
     */
    'token': Token;
}
/**
 * 
 * @export
 * @interface TokenNotFoundError
 */
export interface TokenNotFoundError extends GatewayError {
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof TokenNotFoundError
     */
    'token_not_found': TokenIdentifier;
}
/**
 * 
 * @export
 * @interface TokenNotFoundErrorAllOf
 */
export interface TokenNotFoundErrorAllOf {
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof TokenNotFoundErrorAllOf
     */
    'token_not_found': TokenIdentifier;
}
/**
 * 
 * @export
 * @interface TokenProperties
 */
export interface TokenProperties {
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'icon_url': string;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'symbol': string;
    /**
     * 
     * @type {boolean}
     * @memberof TokenProperties
     */
    'is_supply_mutable': boolean;
    /**
     * 
     * @type {string}
     * @memberof TokenProperties
     */
    'granularity': string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TokenProperties
     */
    'owner'?: AccountIdentifier;
}
/**
 * 
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof TokenRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {TokenIdentifier}
     * @memberof TokenRequest
     */
    'token_identifier': TokenIdentifier;
}
/**
 * 
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof TokenResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Token}
     * @memberof TokenResponse
     */
    'token': Token;
}
/**
 * 
 * @export
 * @interface TransactionBuild
 */
export interface TransactionBuild {
    /**
     * 
     * @type {TokenAmount}
     * @memberof TransactionBuild
     */
    'fee': TokenAmount;
    /**
     * 
     * @type {string}
     * @memberof TransactionBuild
     */
    'unsigned_transaction': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionBuild
     */
    'payload_to_sign': string;
}
/**
 * 
 * @export
 * @interface TransactionBuildRequest
 */
export interface TransactionBuildRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof TransactionBuildRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {Array<Action>}
     * @memberof TransactionBuildRequest
     */
    'actions': Array<Action>;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransactionBuildRequest
     */
    'fee_payer': AccountIdentifier;
    /**
     * 
     * @type {string}
     * @memberof TransactionBuildRequest
     */
    'message'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionBuildRequest
     */
    'disable_token_mint_and_burn'?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionBuildResponse
 */
export interface TransactionBuildResponse {
    /**
     * 
     * @type {TransactionBuild}
     * @memberof TransactionBuildResponse
     */
    'transaction_build': TransactionBuild;
}
/**
 * 
 * @export
 * @interface TransactionFinalizeRequest
 */
export interface TransactionFinalizeRequest {
    /**
     * 
     * @type {string}
     * @memberof TransactionFinalizeRequest
     */
    'network': string;
    /**
     * 
     * @type {string}
     * @memberof TransactionFinalizeRequest
     */
    'unsigned_transaction': string;
    /**
     * 
     * @type {Signature}
     * @memberof TransactionFinalizeRequest
     */
    'signature': Signature;
    /**
     * 
     * @type {boolean}
     * @memberof TransactionFinalizeRequest
     */
    'submit'?: boolean;
}
/**
 * 
 * @export
 * @interface TransactionFinalizeResponse
 */
export interface TransactionFinalizeResponse {
    /**
     * 
     * @type {string}
     * @memberof TransactionFinalizeResponse
     */
    'signed_transaction': string;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionFinalizeResponse
     */
    'transaction_identifier': TransactionIdentifier;
}
/**
 * 
 * @export
 * @interface TransactionIdentifier
 */
export interface TransactionIdentifier {
    /**
     * 
     * @type {string}
     * @memberof TransactionIdentifier
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface TransactionNotFoundError
 */
export interface TransactionNotFoundError extends GatewayError {
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionNotFoundError
     */
    'transaction_not_found': TransactionIdentifier;
}
/**
 * 
 * @export
 * @interface TransactionNotFoundErrorAllOf
 */
export interface TransactionNotFoundErrorAllOf {
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionNotFoundErrorAllOf
     */
    'transaction_not_found': TransactionIdentifier;
}
/**
 * 
 * @export
 * @interface TransactionRules
 */
export interface TransactionRules {
    /**
     * 
     * @type {number}
     * @memberof TransactionRules
     */
    'maximum_message_length'?: number;
    /**
     * 
     * @type {TokenAmount}
     * @memberof TransactionRules
     */
    'minimum_stake'?: TokenAmount;
}
/**
 * 
 * @export
 * @interface TransactionRulesRequest
 */
export interface TransactionRulesRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof TransactionRulesRequest
     */
    'network_identifier': NetworkIdentifier;
}
/**
 * 
 * @export
 * @interface TransactionRulesResponse
 */
export interface TransactionRulesResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof TransactionRulesResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {TransactionRules}
     * @memberof TransactionRulesResponse
     */
    'transaction_rules': TransactionRules;
}
/**
 * 
 * @export
 * @interface TransactionStatusRequest
 */
export interface TransactionStatusRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof TransactionStatusRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionStatusRequest
     */
    'transaction_identifier': TransactionIdentifier;
}
/**
 * 
 * @export
 * @interface TransactionStatusResponse
 */
export interface TransactionStatusResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof TransactionStatusResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {AccountTransaction}
     * @memberof TransactionStatusResponse
     */
    'transaction': AccountTransaction;
}
/**
 * 
 * @export
 * @interface TransactionSubmitRequest
 */
export interface TransactionSubmitRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof TransactionSubmitRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {string}
     * @memberof TransactionSubmitRequest
     */
    'signed_transaction': string;
}
/**
 * 
 * @export
 * @interface TransactionSubmitResponse
 */
export interface TransactionSubmitResponse {
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionSubmitResponse
     */
    'transaction_identifier': TransactionIdentifier;
}
/**
 * 
 * @export
 * @interface TransferTokens
 */
export interface TransferTokens extends Action {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransferTokens
     */
    'from_account': AccountIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransferTokens
     */
    'to_account': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof TransferTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface TransferTokensAllOf
 */
export interface TransferTokensAllOf {
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransferTokensAllOf
     */
    'from_account': AccountIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof TransferTokensAllOf
     */
    'to_account': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof TransferTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface UnstakeTokens
 */
export interface UnstakeTokens extends Action {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof UnstakeTokens
     */
    'from_validator': ValidatorIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof UnstakeTokens
     */
    'to_account': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof UnstakeTokens
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface UnstakeTokensAllOf
 */
export interface UnstakeTokensAllOf {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof UnstakeTokensAllOf
     */
    'from_validator': ValidatorIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof UnstakeTokensAllOf
     */
    'to_account': AccountIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof UnstakeTokensAllOf
     */
    'amount': TokenAmount;
}
/**
 * 
 * @export
 * @interface Validator
 */
export interface Validator {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof Validator
     */
    'validator_identifier': ValidatorIdentifier;
    /**
     * 
     * @type {TokenAmount}
     * @memberof Validator
     */
    'stake': TokenAmount;
    /**
     * 
     * @type {ValidatorInfo}
     * @memberof Validator
     */
    'info': ValidatorInfo;
    /**
     * 
     * @type {ValidatorProperties}
     * @memberof Validator
     */
    'properties': ValidatorProperties;
}
/**
 * 
 * @export
 * @interface ValidatorDeriveRequest
 */
export interface ValidatorDeriveRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ValidatorDeriveRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {PublicKey}
     * @memberof ValidatorDeriveRequest
     */
    'public_key': PublicKey;
}
/**
 * 
 * @export
 * @interface ValidatorDeriveResponse
 */
export interface ValidatorDeriveResponse {
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof ValidatorDeriveResponse
     */
    'account_identifier': ValidatorIdentifier;
}
/**
 * 
 * @export
 * @interface ValidatorIdentifier
 */
export interface ValidatorIdentifier {
    /**
     * 
     * @type {string}
     * @memberof ValidatorIdentifier
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface ValidatorInfo
 */
export interface ValidatorInfo {
    /**
     * 
     * @type {TokenAmount}
     * @memberof ValidatorInfo
     */
    'owner_stake': TokenAmount;
    /**
     * 
     * @type {ValidatorUptime}
     * @memberof ValidatorInfo
     */
    'uptime': ValidatorUptime;
}
/**
 * 
 * @export
 * @interface ValidatorProperties
 */
export interface ValidatorProperties {
    /**
     * 
     * @type {string}
     * @memberof ValidatorProperties
     */
    'url': string;
    /**
     * 
     * @type {number}
     * @memberof ValidatorProperties
     */
    'validator_fee_percentage': number;
    /**
     * 
     * @type {string}
     * @memberof ValidatorProperties
     */
    'name': string;
    /**
     * 
     * @type {boolean}
     * @memberof ValidatorProperties
     */
    'registered': boolean;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof ValidatorProperties
     */
    'owner_account_identifier': AccountIdentifier;
    /**
     * 
     * @type {boolean}
     * @memberof ValidatorProperties
     */
    'external_stake_accepted': boolean;
}
/**
 * 
 * @export
 * @interface ValidatorRequest
 */
export interface ValidatorRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ValidatorRequest
     */
    'network_identifier': NetworkIdentifier;
    /**
     * 
     * @type {ValidatorIdentifier}
     * @memberof ValidatorRequest
     */
    'validator_identifier': ValidatorIdentifier;
}
/**
 * 
 * @export
 * @interface ValidatorResponse
 */
export interface ValidatorResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof ValidatorResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Validator}
     * @memberof ValidatorResponse
     */
    'validator': Validator;
}
/**
 * 
 * @export
 * @interface ValidatorUptime
 */
export interface ValidatorUptime {
    /**
     * 
     * @type {EpochRange}
     * @memberof ValidatorUptime
     */
    'epoch_range': EpochRange;
    /**
     * 
     * @type {number}
     * @memberof ValidatorUptime
     */
    'uptime_percentage': number;
    /**
     * 
     * @type {number}
     * @memberof ValidatorUptime
     */
    'proposals_missed': number;
    /**
     * 
     * @type {number}
     * @memberof ValidatorUptime
     */
    'proposals_completed': number;
}
/**
 * 
 * @export
 * @interface ValidatorsRequest
 */
export interface ValidatorsRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ValidatorsRequest
     */
    'network_identifier': NetworkIdentifier;
}
/**
 * 
 * @export
 * @interface ValidatorsResponse
 */
export interface ValidatorsResponse {
    /**
     * 
     * @type {LedgerState}
     * @memberof ValidatorsResponse
     */
    'ledger_state': LedgerState;
    /**
     * 
     * @type {Array<Validator>}
     * @memberof ValidatorsResponse
     */
    'validators': Array<Validator>;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalancesPost: async (accountBalancesRequest: AccountBalancesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountBalancesRequest' is not null or undefined
            assertParamExists('accountBalancesPost', 'accountBalancesRequest', accountBalancesRequest)
            const localVarPath = `/account/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountBalancesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Derive Account Identifier
         * @param {AccountDeriveRequest} accountDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDerivePost: async (accountDeriveRequest: AccountDeriveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountDeriveRequest' is not null or undefined
            assertParamExists('accountDerivePost', 'accountDeriveRequest', accountDeriveRequest)
            const localVarPath = `/account/derive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountDeriveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStakesPost: async (accountStakesRequest: AccountStakesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountStakesRequest' is not null or undefined
            assertParamExists('accountStakesPost', 'accountStakesRequest', accountStakesRequest)
            const localVarPath = `/account/stakes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountStakesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsPost: async (accountTransactionsRequest: AccountTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountTransactionsRequest' is not null or undefined
            assertParamExists('accountTransactionsPost', 'accountTransactionsRequest', accountTransactionsRequest)
            const localVarPath = `/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUnstakesPost: async (accountUnstakesRequest: AccountUnstakesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountUnstakesRequest' is not null or undefined
            assertParamExists('accountUnstakesPost', 'accountUnstakesRequest', accountUnstakesRequest)
            const localVarPath = `/account/unstakes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountUnstakesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Gateway Info
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('gatewayPost', 'body', body)
            const localVarPath = `/gateway`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDerivePost: async (tokenDeriveRequest: TokenDeriveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenDeriveRequest' is not null or undefined
            assertParamExists('tokenDerivePost', 'tokenDeriveRequest', tokenDeriveRequest)
            const localVarPath = `/token/derive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenDeriveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenNativePost: async (tokenNativeRequest: TokenNativeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenNativeRequest' is not null or undefined
            assertParamExists('tokenNativePost', 'tokenNativeRequest', tokenNativeRequest)
            const localVarPath = `/token/native`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenNativeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost: async (tokenRequest: TokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequest' is not null or undefined
            assertParamExists('tokenPost', 'tokenRequest', tokenRequest)
            const localVarPath = `/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionBuildPost: async (transactionBuildRequest: TransactionBuildRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionBuildRequest' is not null or undefined
            assertParamExists('transactionBuildPost', 'transactionBuildRequest', transactionBuildRequest)
            const localVarPath = `/transaction/build`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionBuildRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionFinalizePost: async (transactionFinalizeRequest: TransactionFinalizeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionFinalizeRequest' is not null or undefined
            assertParamExists('transactionFinalizePost', 'transactionFinalizeRequest', transactionFinalizeRequest)
            const localVarPath = `/transaction/finalize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionFinalizeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRulesPost: async (transactionRulesRequest: TransactionRulesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionRulesRequest' is not null or undefined
            assertParamExists('transactionRulesPost', 'transactionRulesRequest', transactionRulesRequest)
            const localVarPath = `/transaction/rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionRulesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Transaction
         * @param {TransactionStatusRequest} transactionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionStatusPost: async (transactionStatusRequest: TransactionStatusRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionStatusRequest' is not null or undefined
            assertParamExists('transactionStatusPost', 'transactionStatusRequest', transactionStatusRequest)
            const localVarPath = `/transaction/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionSubmitPost: async (transactionSubmitRequest: TransactionSubmitRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionSubmitRequest' is not null or undefined
            assertParamExists('transactionSubmitPost', 'transactionSubmitRequest', transactionSubmitRequest)
            const localVarPath = `/transaction/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(transactionSubmitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Validator Identifier
         * @param {ValidatorDeriveRequest} validatorDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDerivePost: async (validatorDeriveRequest: ValidatorDeriveRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorDeriveRequest' is not null or undefined
            assertParamExists('validatorDerivePost', 'validatorDeriveRequest', validatorDeriveRequest)
            const localVarPath = `/validator/derive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorDeriveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Validator
         * @param {ValidatorRequest} validatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorPost: async (validatorRequest: ValidatorRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorRequest' is not null or undefined
            assertParamExists('validatorPost', 'validatorRequest', validatorRequest)
            const localVarPath = `/validator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsPost: async (validatorsRequest: ValidatorsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorsRequest' is not null or undefined
            assertParamExists('validatorsPost', 'validatorsRequest', validatorsRequest)
            const localVarPath = `/validators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validatorsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountBalancesPost(accountBalancesRequest: AccountBalancesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountBalancesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountBalancesPost(accountBalancesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Derive Account Identifier
         * @param {AccountDeriveRequest} accountDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountDerivePost(accountDeriveRequest: AccountDeriveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDeriveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountDerivePost(accountDeriveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountStakesPost(accountStakesRequest: AccountStakesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountStakesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountStakesPost(accountStakesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountTransactionsPost(accountTransactionsRequest: AccountTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountTransactionsPost(accountTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountUnstakesPost(accountUnstakesRequest: AccountUnstakesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountUnstakesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountUnstakesPost(accountUnstakesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Gateway Info
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async gatewayPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GatewayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.gatewayPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenDerivePost(tokenDeriveRequest: TokenDeriveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenDeriveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenDerivePost(tokenDeriveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenNativePost(tokenNativeRequest: TokenNativeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenNativeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenNativePost(tokenNativeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tokenPost(tokenRequest: TokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tokenPost(tokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionBuildPost(transactionBuildRequest: TransactionBuildRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionBuildResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionBuildPost(transactionBuildRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionFinalizePost(transactionFinalizeRequest: TransactionFinalizeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionFinalizeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionFinalizePost(transactionFinalizeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionRulesPost(transactionRulesRequest: TransactionRulesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionRulesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionRulesPost(transactionRulesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Transaction
         * @param {TransactionStatusRequest} transactionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionStatusPost(transactionStatusRequest: TransactionStatusRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionStatusPost(transactionStatusRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async transactionSubmitPost(transactionSubmitRequest: TransactionSubmitRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionSubmitResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.transactionSubmitPost(transactionSubmitRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Validator Identifier
         * @param {ValidatorDeriveRequest} validatorDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorDerivePost(validatorDeriveRequest: ValidatorDeriveRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorDeriveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorDerivePost(validatorDeriveRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Validator
         * @param {ValidatorRequest} validatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorPost(validatorRequest: ValidatorRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorPost(validatorRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validatorsPost(validatorsRequest: ValidatorsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidatorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validatorsPost(validatorsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Get Account Balances
         * @param {AccountBalancesRequest} accountBalancesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalancesPost(accountBalancesRequest: AccountBalancesRequest, options?: any): AxiosPromise<AccountBalancesResponse> {
            return localVarFp.accountBalancesPost(accountBalancesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Derive Account Identifier
         * @param {AccountDeriveRequest} accountDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDerivePost(accountDeriveRequest: AccountDeriveRequest, options?: any): AxiosPromise<AccountDeriveResponse> {
            return localVarFp.accountDerivePost(accountDeriveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Stake Positions
         * @param {AccountStakesRequest} accountStakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountStakesPost(accountStakesRequest: AccountStakesRequest, options?: any): AxiosPromise<AccountStakesResponse> {
            return localVarFp.accountStakesPost(accountStakesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Account Transactions
         * @param {AccountTransactionsRequest} accountTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountTransactionsPost(accountTransactionsRequest: AccountTransactionsRequest, options?: any): AxiosPromise<AccountTransactionsResponse> {
            return localVarFp.accountTransactionsPost(accountTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Unstake Positions
         * @param {AccountUnstakesRequest} accountUnstakesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountUnstakesPost(accountUnstakesRequest: AccountUnstakesRequest, options?: any): AxiosPromise<AccountUnstakesResponse> {
            return localVarFp.accountUnstakesPost(accountUnstakesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Gateway Info
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        gatewayPost(body: object, options?: any): AxiosPromise<GatewayResponse> {
            return localVarFp.gatewayPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Derive Token Identifier
         * @param {TokenDeriveRequest} tokenDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenDerivePost(tokenDeriveRequest: TokenDeriveRequest, options?: any): AxiosPromise<TokenDeriveResponse> {
            return localVarFp.tokenDerivePost(tokenDeriveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Native Token Info
         * @param {TokenNativeRequest} tokenNativeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenNativePost(tokenNativeRequest: TokenNativeRequest, options?: any): AxiosPromise<TokenNativeResponse> {
            return localVarFp.tokenNativePost(tokenNativeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Token Info
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tokenPost(tokenRequest: TokenRequest, options?: any): AxiosPromise<TokenResponse> {
            return localVarFp.tokenPost(tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Build Transaction
         * @param {TransactionBuildRequest} transactionBuildRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionBuildPost(transactionBuildRequest: TransactionBuildRequest, options?: any): AxiosPromise<TransactionBuildResponse> {
            return localVarFp.transactionBuildPost(transactionBuildRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Finalize Transaction
         * @param {TransactionFinalizeRequest} transactionFinalizeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionFinalizePost(transactionFinalizeRequest: TransactionFinalizeRequest, options?: any): AxiosPromise<TransactionFinalizeResponse> {
            return localVarFp.transactionFinalizePost(transactionFinalizeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transaction Rules
         * @param {TransactionRulesRequest} transactionRulesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionRulesPost(transactionRulesRequest: TransactionRulesRequest, options?: any): AxiosPromise<TransactionRulesResponse> {
            return localVarFp.transactionRulesPost(transactionRulesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Transaction
         * @param {TransactionStatusRequest} transactionStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionStatusPost(transactionStatusRequest: TransactionStatusRequest, options?: any): AxiosPromise<TransactionStatusResponse> {
            return localVarFp.transactionStatusPost(transactionStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Submit Transaction
         * @param {TransactionSubmitRequest} transactionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transactionSubmitPost(transactionSubmitRequest: TransactionSubmitRequest, options?: any): AxiosPromise<TransactionSubmitResponse> {
            return localVarFp.transactionSubmitPost(transactionSubmitRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Validator Identifier
         * @param {ValidatorDeriveRequest} validatorDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorDerivePost(validatorDeriveRequest: ValidatorDeriveRequest, options?: any): AxiosPromise<ValidatorDeriveResponse> {
            return localVarFp.validatorDerivePost(validatorDeriveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Validator
         * @param {ValidatorRequest} validatorRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorPost(validatorRequest: ValidatorRequest, options?: any): AxiosPromise<ValidatorResponse> {
            return localVarFp.validatorPost(validatorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Validators
         * @param {ValidatorsRequest} validatorsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validatorsPost(validatorsRequest: ValidatorsRequest, options?: any): AxiosPromise<ValidatorsResponse> {
            return localVarFp.validatorsPost(validatorsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Get Account Balances
     * @param {AccountBalancesRequest} accountBalancesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountBalancesPost(accountBalancesRequest: AccountBalancesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountBalancesPost(accountBalancesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Derive Account Identifier
     * @param {AccountDeriveRequest} accountDeriveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountDerivePost(accountDeriveRequest: AccountDeriveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountDerivePost(accountDeriveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Stake Positions
     * @param {AccountStakesRequest} accountStakesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountStakesPost(accountStakesRequest: AccountStakesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountStakesPost(accountStakesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Account Transactions
     * @param {AccountTransactionsRequest} accountTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountTransactionsPost(accountTransactionsRequest: AccountTransactionsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountTransactionsPost(accountTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Unstake Positions
     * @param {AccountUnstakesRequest} accountUnstakesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public accountUnstakesPost(accountUnstakesRequest: AccountUnstakesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).accountUnstakesPost(accountUnstakesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Gateway Info
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public gatewayPost(body: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).gatewayPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Derive Token Identifier
     * @param {TokenDeriveRequest} tokenDeriveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenDerivePost(tokenDeriveRequest: TokenDeriveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenDerivePost(tokenDeriveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Native Token Info
     * @param {TokenNativeRequest} tokenNativeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenNativePost(tokenNativeRequest: TokenNativeRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenNativePost(tokenNativeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Token Info
     * @param {TokenRequest} tokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public tokenPost(tokenRequest: TokenRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).tokenPost(tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Build Transaction
     * @param {TransactionBuildRequest} transactionBuildRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionBuildPost(transactionBuildRequest: TransactionBuildRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionBuildPost(transactionBuildRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Finalize Transaction
     * @param {TransactionFinalizeRequest} transactionFinalizeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionFinalizePost(transactionFinalizeRequest: TransactionFinalizeRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionFinalizePost(transactionFinalizeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transaction Rules
     * @param {TransactionRulesRequest} transactionRulesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionRulesPost(transactionRulesRequest: TransactionRulesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionRulesPost(transactionRulesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Transaction
     * @param {TransactionStatusRequest} transactionStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionStatusPost(transactionStatusRequest: TransactionStatusRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionStatusPost(transactionStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Submit Transaction
     * @param {TransactionSubmitRequest} transactionSubmitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public transactionSubmitPost(transactionSubmitRequest: TransactionSubmitRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).transactionSubmitPost(transactionSubmitRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Validator Identifier
     * @param {ValidatorDeriveRequest} validatorDeriveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public validatorDerivePost(validatorDeriveRequest: ValidatorDeriveRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).validatorDerivePost(validatorDeriveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Validator
     * @param {ValidatorRequest} validatorRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public validatorPost(validatorRequest: ValidatorRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).validatorPost(validatorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Validators
     * @param {ValidatorsRequest} validatorsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public validatorsPost(validatorsRequest: ValidatorsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).validatorsPost(validatorsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


